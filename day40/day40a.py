'''

线程是进程中的执行单位
线程是cpu执行的最小单位
线程之间资源共享
线程的开启和关闭以及切换的时间开销远远小于进程
线程本身可以在同一时间使用多个cpu

python与线程
  cpython解释器在解释代码过程中容易产生数据不安全的问题
  gil全局解释器锁  锁的是线程

threading

守护线程
   守护进程会随着主进程代码的执行结束而结束
   守护线程会在主线程结束后之后等待其他子线程的结束才结束

  无论是进程还是线程，都遵循 守护xx回等待主xx运行完毕后被销毁
  需要强调的是 运行完毕并非终止运行
  对主进程来说 ，运行完毕指的是主进程代码运行完毕
  对主线程来说，运行完毕指的是主线程所在进程内所有非守护线程统统运行完毕，主线程才算运行完毕


  主进程在其代码结束后就已经算运算完毕了（守护进程在此时就被回收）然后主进程
  回一直等待非守护的子进程都运行完毕后。回收子进程的资源（否则回产生僵尸进程），才回结束

   主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束异味着进程的结束
   进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束

也就是说  守护线程和守护进程都会随着被守护的线程和进程代码执行结束而结束，
但是 主线程回进程内其他非守护线程结束，才会结束，就算主线程的代码执行完毕
也只是在阻塞等待，一个进程内必须要有一个主线程，主线程的结束意味着该进程结束

'''

#守护线程

from threading import Thread
import time
def func1():
    print('start守护进程')
    time.sleep(10)
    print('end守护进程')
def func2():
    print('ok')
    time.sleep(3)
if __name__ == '__main__':

    t=Thread(target=func1,)
    t.daemon=True
    t.start()
    t1=Thread(target=func2,)
    t1.start()

    print('主线程')
    #打印结果很明显守护线程随着
    # 主线程和子线程的代码结束，
    # 守护线程中的最后一句没有打印
    # 意味着没有守护线程随着同进程中其他非守护
    # 线程的结束而结束
