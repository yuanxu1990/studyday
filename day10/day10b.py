'''

命名空间 作用域

      内置命名空间------python解释器
            python解释器已启动就可以使用的名字储存在内置命名空间中
            内置的名字在启动解释器的时候被加载进内存里
      全局的命名空间-------自己写的代码除了函数中的代码
             实在程序从上倒下的过程中一次加载进内存的
             放置了我们设置的所有变量名和函数名
      局部的命名空间-------函数
              就是函数内部定义的名字
              当调用函数的时候，才会产生这个名称空间，随着函数执行的结束，这个命名空间就销毁了


       加载顺序 ：
               python解释器启动加载内置空间 然后才开始读取代码
               这时候加载全局命名空间，在调取函数的时候才会加载局部命名空间


      依赖关系 局部》》全局》》内置

      在正常情况下，直接使用内置函数的名字
      当我们全局定义了和内置函数相同的名字的时候，回使用全局的名字
      当程序处于全局的时候，会在本级寻找，如果找不到才会去像上层去寻找

'''
#命名空间
# def input():
#
#     print('addd')
#
# def func_02():
#     input()
#
# func_02()
# print(id(func_02))#  函数所在物理内存地址
# print(func_02)#16进制  函数的地址

'''
作用域
      全局作用域-----作用在全局--内置和全局名字空间中的名字都属于全局作用域 globals（）
      局部作用域-----作用在局部----函数                                      locals()

    
    
    
对于不可变数据类型 在局部可查看全局作用域中的变量
但是不能直接修改
如果想要修改 需要在函数内添加global生命
如果在一个局部（函数）声明了global变量，那么这个变量在局部内所有操作会对全局产生影响
'''
# a=1
# def func_05():
#     global a
#     a=2
#
# # func_05()
# print(a)



#函数的嵌套调用
# def max(a,b):
#     return a if a>b else b
# def the_max(x,y,z):
#     c=max(x,y)
#     return max(c,z)
#
#
# print(the_max(1,2,3))


#函数的嵌套定义
# a=1
# def outer():
#     a=1
#     def inner():
#         b=2
#         print('inner')
#         print(a)
#         def inner2():
#             nonlocal a #声明了 一个上层局部变量
#             #global a#只要声明了global 就是直接去全局变量中去取，而不不会在同级局部中去取
#             a+=1
#             print('inner2')
#             print(b)
#         inner2()
#     inner()
#     print('**a**',a)
#
# # outer()
#
# func_05=outer
# func_05()
# print('全局a',a)
# 不可变数据类型的修改 需要声明global 注意global的作用域
#python3中 新家了nonlocal 只能用于局部变量 找上层中离当前函数最近一层的局部变量
#函数名就是内存地址  函数名可以赋值 在加（）一样调用
#函数名也可以做容器类型（可变数据类型）的元素
#函数名可以做函数的参数
#函数可以做为返回值

def func_06():
    print(123)
def ok(f):
    f()

ok(func_06)
