'''


进程
     程序并不能单独运行，只有将程序装在到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。
     程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本，进程是程序的一次执行活动，属于
     动态概念，在多道变成中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发的地执行，
     这样的设计，大大提高了cpu的利用率，进程的出现每个用户感觉到自己独享cpu，因此，进程就是为了在cpu上实现多道编程而提出的

进程的缺点：
    进程只能在一个时间干一件事 如果想同时干两件事或者或者多件事
    进程在执行过程中如果阻塞 例如等待输入 整个进程都回被挂起，即使进程中有些工作不依赖于输入的数据
    也将无法执行

进程是资源分配的最小单位  线程是cpu调度的最小单位
每一个进程至少有一个线程


进程和线程的区别
1 地址空间和其他资源（入打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其他进程不可见
2 通信：进程间通信ipc 线程间可以直接读取进程数据段（全局变量）来进程通信---需要进程同步和互斥手段的辅助，以保证数据的一致性
3调度和切换  线程上下文切换比进程上下文切换要快的多
4 在多线程操作系统中，进程不是一个可执行的实体


线程的属性：
1 轻型实体
          线程中的实体基本上不拥有系统资源，只是有一点必不可少的，能保证独立运行的资源
          线程的实体包括程序 数据和TCB。线程是动态概念，他的动态特性由线程控制块TCB（thread Control Block）

2 独立调度和分派的基本单位
           在多线程os中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很 轻  故线程的切换
           非常迅速且开销小（在同一进程中的）
3 共享进程资源
           线程在同一进程中的各个线程，都可以共享该进程所拥有的资源。这首先表现在：所有的线程都具备相同的进程id
           这意味着，线程可以访问该进程的内一个内存资源。此外，还可以访问进程所有拥有的已打开文件 定时器 信号量机构
           等。由于统一进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核
4 可并发执行
   在一个进程中的多个线程中，可以并发执行，甚至允许一个进程中所有的线程都能并发执行。同样，不同进程中的线程也能并发执行。
   充分利用和发挥了处理机与外围设备的并行工作的能力


全局解释器锁GIL
  python代码执行由python虚拟机（也叫解释器主循环）来控制。python在设计支出就考虑到要在主循环中，同时只有一个线程在执行
  。虽然python解释器中可以运行多个线程。但是在任意时刻只能有一个线程在解释器中运行
    对python虚拟机的访问由全局解释器锁GIL控制，正是这个锁能保证统一时刻只能有一个线程在运行
    a 设置gil
    b 切换到一个线程去运行
    c 运行指定数量的字节码指令或者线程主动让出控制（可以调用 time.sleep(0)）
    d 把线程设置为睡眠状态
    e 解锁gil
    f 再次重复以上所有步骤


　Python提供了几个用于多线程编程的模块，包括thread、threading和Queue等。thread和threading模块允许程序员创建和管理线程。
   thread模块提供了基本的线程和锁的支持，threading提供了更高级别、功能更强的线程管理的功能。
   Queue模块允许用户创建一个可以用于多个线程之间共享数据的队列数据结构。
　　避免使用thread模块，因为更高级别的threading模块更为先进，对线程的支持更为完善，
    而且使用thread模块里的属性有可能会与threading出现冲突；其次低级别的thread模块的同步原语很少(实际上只有一个)，
    而threading模块则有很多；再者，thread模块中当主线程结束时，所有的线程都会被强制结束掉，没有警告也不会有正常的清除工作，
    至少threading模块能确保重要的子线程退出后进程才退出。

　　thread模块不支持守护线程，当主线程退出时，所有的子线程不论它们是否还在工作，都会被强行退出。
     而threading模块支持守护线程，守护线程一般是一个等待客户请求的服务器，如果没有客户提出请求它就在那等着，
     如果设定一个线程为守护线程，就表示这个线程是不重要的，在进程退出的时候，不用等待这个线程退出。
'''
from threading import Thread
import time,os

#第一种启动多线程方法
# def func(n):
#     time.sleep(1)
#     print(n)
# #if __name__ == '__main__':
#
# for i in range(10):
#     t=Thread(target=func,args=(i,))
#     t.start()

#第二种启动多线程方法

# class mythread(Thread):
#     def __init__(self,arg):
#         super().__init__()
#         self.arg=arg
#     def run(self):
#         time.sleep(1)
#         print(self.arg)
#
# t=mythread(10)
# t.start()


#多线程并发

# def func(a,b):
#     n=a+b
#     print(n,os.getpid())
# print('主线程',os.getpid())
# for i in range(10):
#     t=Thread(target=func,args=(i,5))
#     t.start()

#内存数据的共享问题

def func(a,b):
    global g
    g=0
    print(g,os.getpid())
g=100
t_lis=[]
for i in range(10):
    t=Thread(target=func,args=(i,5))
    t.start()
    t_lis.append(t)
[a.join() for a in t_lis]
print(g)