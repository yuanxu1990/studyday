'''

基于tcp实现远程执行命令

在server端下发命令
在client端接受命令

此文件和day31dc  用于测试  黏包 现象
                 黏包  主要现象  数据错乱 send的数据长度  超过了recv的长度


黏包的成因
         tcp协议的拆包机制：
             当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。
             MTU是Maximum Transmission Unit的缩写。意思是网络上传送的最大数据包。MTU的单位是字节。
              大部分网络设备的MTU都是1500。如果本机的MTU比网关的MTU大，大的数据包就会被拆开来传送，
              这样会产生很多数据包碎片，增加丢包率，降低网络速度。
         面向流的通信特点和Nagle算法
              TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。
                收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，
                更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，
                然后进行封包。
                这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。
                对于空消息：tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制
                防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），也可以被发送，
                udp协议会帮你封装上消息头发送过去。
                可靠黏包的tcp协议：tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，
                己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。

udp是不会发生黏包的：
        UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。
        不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）
        采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息）

        ，这样，对于接收端来说，就容易进行区分处理了。 即面向消息的通信是有消息保护边界的。
        对于空消息：tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空
        消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），
        也可以被发送，udp协议会帮你封装上消息头发送过去。
        不可靠不黏包的udp协议：udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y)
        ,收完了x个字节的数据就算完成,若是y;x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠。
 udp和tcp长度：
用UDP协议发送时，用sendto函数最大能发送数据的长度为：65535- IP头(20) – UDP头(8)＝65507字节。
用sendto函数发送数据时，如果发送数据长度大于该值，则函数会返回错误。（丢弃这个包，不进行发送）

用TCP协议发送时，由于TCP是数据流协议，因此不存在包大小的限制（暂不考虑缓冲区的大小），
这是指在用send函数时，数据长度参数不受限制。而实际上，所指定的这段数据并不一定会一次性发送出去，
如果这段数据比较长，会被分段发送，如果比较短，可能会等待和下一次数据一起发送。



造成黏包的两种情况
1 发送发送方的缓存机制
    发送端需要缓冲区满才发送出去，造成黏包（发送数据时间间隔很短，数据又很小，回合并到一起，产生黏包）
2  接受方的缓存机制
   接收方不及时接受缓冲区的包，造成多个包接受（客户端发送了一段数据，服务端只收了一部分），服务端再次接受的
   的时候，还会从缓冲区拿缓冲区遗留的数据，产生黏包

黏包现象只发生在tcp协议中：
   1 表面上看 黏包问题主要是因为发送方和接收方的缓存机制，tcp协议面向流通信的特点
   2 实际上 主要还是因为接受方不知道消息之间的界限，不知道一次性提取多少自己的数据造成的
'''

import socket

sk=socket.socket()
sk.bind(('127.0.0.1',10050))
sk.listen()


conn,addr=sk.accept()
while True:
    cmd=input('input cmd-->').encode('utf-8')
    conn.send(cmd)
    ret=conn.recv(4096).decode('utf-8')
    print(ret)
conn.close()
sk.close()